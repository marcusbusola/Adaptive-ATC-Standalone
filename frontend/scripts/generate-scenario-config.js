/**
 * Generate Frontend Scenario Config from Backend Manifest
 *
 * This script reads the scenario_manifest.json from the backend and generates
 * a JavaScript configuration file for the frontend. Run this as part of the
 * build process to ensure frontend and backend stay in sync.
 *
 * Usage: node scripts/generate-scenario-config.js
 */

const fs = require('fs');
const path = require('path');

// Paths
const MANIFEST_PATH = path.join(__dirname, '../../backend/scenarios/scenario_manifest.json');
const OUTPUT_PATH = path.join(__dirname, '../src/scenarios/scenarioConfig.generated.js');

function generateConfig() {
  console.log('Generating frontend scenario config from manifest...');

  // Read the manifest
  let manifest;
  try {
    const manifestContent = fs.readFileSync(MANIFEST_PATH, 'utf8');
    manifest = JSON.parse(manifestContent);
  } catch (error) {
    // If manifest doesn't exist (e.g., separate deployment), check if generated file exists
    console.warn(`Warning: Could not read manifest: ${error.message}`);
    console.warn(`Expected manifest at: ${MANIFEST_PATH}`);

    // Check if the generated file already exists (e.g., checked into repo or from previous build)
    if (fs.existsSync(OUTPUT_PATH)) {
      console.log(`Using existing generated config at: ${OUTPUT_PATH}`);
      console.log('Skipping generation - manifest not available but config exists.');
      process.exit(0); // Success - config already exists
    }

    // Also check for a fallback manifest in the frontend directory
    const FALLBACK_MANIFEST_PATH = path.join(__dirname, '../src/scenarios/scenario_manifest.json');
    if (fs.existsSync(FALLBACK_MANIFEST_PATH)) {
      console.log(`Using fallback manifest at: ${FALLBACK_MANIFEST_PATH}`);
      const fallbackContent = fs.readFileSync(FALLBACK_MANIFEST_PATH, 'utf8');
      manifest = JSON.parse(fallbackContent);
    } else {
      console.error('No manifest available and no existing generated config found.');
      console.error('Please ensure scenario_manifest.json exists in backend/scenarios/ or frontend/src/scenarios/');
      process.exit(1);
    }
  }

  // Transform manifest to frontend format
  const scenarios = {};
  for (const [id, config] of Object.entries(manifest)) {
    scenarios[id] = {
      id: config.id,
      name: config.name,
      description: config.description,
      complexity: config.complexity,
      workload: config.workload,
      aircraftCount: config.aircraft_count,
      duration: config.duration_seconds,
      alertFrequency: config.alert_frequency,
      phases: config.phases,
      sagatProbeTimes: config.sagat_probe_times,
      eventTypes: config.event_types,
      keyMeasurements: config.key_measurements,
      expectedDetectionTimes: config.expected_detection_times,
      // Include optional fields if present
      ...(config.weather_system && { weatherSystem: config.weather_system }),
      ...(config.trust_calibration && { trustCalibration: config.trust_calibration }),
      ...(config.expected_detection_rates && { expectedDetectionRates: config.expected_detection_rates }),
      ...(config.expected_response_times && { expectedResponseTimes: config.expected_response_times }),
    };
  }

  // Generate the JavaScript file content
  const fileContent = `/**
 * ATC Scenario Configurations (Auto-Generated)
 *
 * DO NOT EDIT THIS FILE DIRECTLY!
 * This file is auto-generated from backend/scenarios/scenario_manifest.json
 * Run: npm run generate-config (or it runs automatically on build)
 *
 * Generated at: ${new Date().toISOString()}
 */

export const scenarios = ${JSON.stringify(scenarios, null, 2)};

/**
 * Get scenario by ID
 */
export function getScenario(scenarioId) {
  return scenarios[scenarioId] || null;
}

/**
 * Get all scenarios as array
 */
export function getAllScenarios() {
  return Object.values(scenarios);
}

/**
 * Get all scenario IDs
 */
export function getScenarioIds() {
  return Object.keys(scenarios);
}

/**
 * Calculate workload score for a scenario (0-1)
 */
export function calculateWorkload(scenarioId) {
  const scenario = getScenario(scenarioId);
  if (!scenario) return 0;

  const complexityScore = scenario.complexity === 'high' ? 0.6 : 0.2;
  const trafficScore = (scenario.aircraftCount / 20) * 0.4;

  return Math.min(complexityScore + trafficScore, 1);
}

/**
 * Get phase at a given time
 */
export function getPhaseAtTime(scenarioId, elapsedSeconds) {
  const scenario = getScenario(scenarioId);
  if (!scenario || !scenario.phases) return null;

  for (let i = scenario.phases.length - 1; i >= 0; i--) {
    if (elapsedSeconds >= scenario.phases[i].start) {
      return scenario.phases[i];
    }
  }
  return scenario.phases[0];
}

/**
 * Check if a SAGAT probe should trigger at the given time
 */
export function getSagatProbeAtTime(scenarioId, elapsedSeconds, tolerance = 1) {
  const scenario = getScenario(scenarioId);
  if (!scenario || !scenario.sagatProbeTimes) return null;

  for (const probeTime of scenario.sagatProbeTimes) {
    if (Math.abs(elapsedSeconds - probeTime) <= tolerance) {
      return probeTime;
    }
  }
  return null;
}

/**
 * Get expected detection time for a condition
 */
export function getExpectedDetectionTime(scenarioId, condition) {
  const scenario = getScenario(scenarioId);
  if (!scenario || !scenario.expectedDetectionTimes) return null;

  const conditionKey = \`condition_\${condition}_\${condition === 1 ? 'traditional' : condition === 2 ? 'adaptive' : 'ml'}\`;

  // Handle nested structure (like L2) or flat structure
  if (typeof scenario.expectedDetectionTimes === 'object' && !Array.isArray(scenario.expectedDetectionTimes)) {
    // Check if it's nested (has sub-objects with condition keys)
    const firstValue = Object.values(scenario.expectedDetectionTimes)[0];
    if (typeof firstValue === 'object') {
      // Return the whole object for scenarios with multiple measurements
      return scenario.expectedDetectionTimes;
    }
    // Flat structure
    return scenario.expectedDetectionTimes[conditionKey];
  }

  return null;
}

export default scenarios;
`;

  // Write the output file
  try {
    fs.writeFileSync(OUTPUT_PATH, fileContent, 'utf8');
    console.log(`Successfully generated: ${OUTPUT_PATH}`);
    console.log(`Scenarios included: ${Object.keys(scenarios).join(', ')}`);
  } catch (error) {
    console.error(`Error writing output: ${error.message}`);
    process.exit(1);
  }
}

// Run the generator
generateConfig();
